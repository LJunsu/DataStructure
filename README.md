# 자료구조


+ ## 시간복잡도

+ 표기법
  
  자료구조, 알고리즘의 성능을 표기하기 위함
  
  최선보다는 최악을 중점으로


+ n
  
  배열의 길이(데이터의 총 갯수)
  
  배열에서 특정 값을 찾는 작업량 -> n


+ Big-O
  
  최악의 경우

  
+ Theta
  
  Big-O === Big-Omega

  
+ Big-Omega
  
  최선의 경우


+ 시간 복잡도 빅오 표기법
  
  O(1) : 최선(상수)
  
  O(log n) : for문 i++처럼 순차적인 흐름이 아닌, 곱하기, 나누기, 배수 등 조건이 절반이 되는 상황
  
  O(n) : for문 (i++)
  
  O(n log n) : 이중 for문 중 바깥 for문인 i는 n (i++), 안쪽 for문이 j는 (예: j * 2)인 경우 / 여기까지는 선방

  O(n^2) : 이중 for문 (i++)
  
  O(n^3) : 삼중 for문 (i++) / 마지노선
  
  O(2n) : X
  
  O(n!) : X


+ ## 연결 리스트 (Linked List)

+ 활용처

  메모리 단편화 방지, 삽입/삭제 빈번할 때
  

+ 메모리에 [1, 2, 3, 4, 5] 형태의 배열과 객체가 존재한다면
  
  | A | B | C | D | E | F | G | H | I | J | K | L |
  | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
  | 배열 | 1 | 2 | 3 | 4 | 5 | 객체 | a | b | c | 6 |   |
  
  6을 추가하면 기존 배열의 마지막에 연속되게 추가될 것이라 생각했지만, 해당 위치에는 이미 객체가 선점하고 있다.

  그래서 메모리 K 위치에 6이 추가되었다.
  

  연속되지 않은 메모리 공간에 저장된 데이터를, 연속된 것처럼 연결해서 관리하기 위한 자료구조

  각 Node는 다음 Node의 주소를 저장하여 연결한 형태


+ 시간 복잡도
  생성 O(n), 조회 O(n), 수정 O(n), 삭제 O(n)

  공간 복잡도 - O(n)

  
+ ## 스택 (Stack)

+ 활용처

  함수 호출, 되돌리기(Undo)
  

+ LIFO : 후입선출
  
  length를 가질 수 있으며, 스택에 정해진 크기를 초과하면 스택오버플로우

  push↘  ↗pop
  
      │    │
      
      │    │
      
      └━━━━┘

    push O(1), pop O(1)


+ ## 큐 (Queue)

+ 활용처

  작업 대기열, BFS, 비동기 처리

  
+ FIFO : 선입선출

  대기열의 개념으로 한 번에 하나씩만 처리할 수 있는 프로그래밍 환경에서 사용

  ←shift [1, 2, 3, 4, 5] ←push

  push O(1), shift O(1)


+ ## 트리 (Tree)

+ 트리 구조
  
  트리의 시작점 : Root

  가지치기처럼 뻗어가는 가지 : Node

  가지의 마지막 : Leap

  HTML의 구조도 트리 구조로 볼 수 있음


+ 활용

  트리의 Node의 갯수에 대한 제한이 없기 때문에 알고리즘으로 트리를 활용하기 어려움

  그래서 트리의 모양에 제한을 둠 -> 이진 트리 (Binary Tree) - Node를 최대 2개로 제한


+ 이진 트리 종류

  + 정 이진 트리 (Full Binary Tree)

    자식 Node가 0 혹은 2 (자식 Node가 1개는 안됨)

  + 포화 이진 트리 (Perfect Binary Tree)

    leaf가 아닌 Node는 자식이 꼭 2개
    
    leaf는 모두 같은 Level에 있어야 하며, 같은 층에 leaf가 꽉 차있어야 함(삼각형 모양)

  + 완전 이진 트리 (Complete Binary Tree)

    Full과 Perfect의 중간

    왼쪽부터 하나 씩 데이터를 채우는 방식

    이 과정 중 나오는 모든 Tree들이 Complete Tree

    마지막 Level까지 꽉 차있지 않아도 되지만, Node가 왼쪽에서 오른쪽 방향으로 채워져 있어야 함.

  + 편향 이진 트리 (Degenerate(Skewed) Binary Tree)

    자식의 갯수가 모두 1개인 트리

    가장 비효율적인 이진 트리 (연결 리스트 수준의 트리 형태)

    모든 Node들이 diff가 0 혹은 1인 트리 (좌, 우 어느쪽으로 치우쳐져 있는지 판단할 때 diff를 사용)


  + 용어

    + Level (가지의 층)

      Root는 Level 1, 그 다음 2개로 나눠진 가지(자식)의 층 Level 2 ...

    + height
   
      Root로 부터 가지치기된 가지의 길이

    + diff

      Root의 diff는 1

      자신을 기준으로 왼쪽 최대 height와 오른쪽 최대 height의 차이


+ ## 이진 탐색 트리 (Binary Search Tree)

+ 활용처
  
  정렬된 데이터를 효율적으로 탐색, 삽입, 삭제해야 하는 상황


+ 이진 트리는 가지가 최대 2개이며 이진 탐색 트리에서 사용하기 좋은 트리는 Balanced Tree (Complete, Perfect는 Balabced일 수 밖에 없음)


+ Node를 기준으로 왼쪽은 작은 값, 오른쪽은 큰 값을 배치


+ 탐색 -> 정렬이 되었음을 의미

  정렬이 되어있어 특정 값에 접근할 때, 삽입, 조회, 삭제 모두 O(log n)

  단, Balanced Tree일 때 해당 (이진 탐색 트리는 Balanced를 보장하지 않음)

  Balanced를 보장하기 위해 AVL Tree, Red Black Tree 등 작업이 필요

  트리가 한 쪽으로만 채워져서 연결 리스트 형태가 된다면 삽입, 조회, 삭제 모두 O(n)


+ ## 이진 힙 (Binary Heap)

+ Complete Binary Tree를 사용

  Complete Binary Tree는 배열로 표현할 수 있음

  새로운 Node를 추가해도 힙 구조가 유지 되어야 함

  Node 삭제는 Root Node만 제거 가능하며 삭제 후 힙 구조가 유지 되어야 함

+ 배열에서 노드를 구하는 공식
  
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

  + 왼쪽 자식 노드를 구하는 공식 -> 인덱스 * 2 + 1

    2 * 2 + 1 = 5

    2 * 2 + 2 = 6

  + 오른쪽 자식 노드를 구하는 공식 -> 인덱스 * 2 + 2

    4 * 2 + 1 = 9
  
    4 * 2 + 2 = 10 (null)

  + 부모를 구하는 공식 -> Math.floor( (인덱스 - 1) / 2 )

    (7 - 1) / 2 = 3
    (8 - 1) / 2 = 3.5 = 3


+ 최대 힙 & 최소 힙

  최대 힙 : 위가 크고, 아래가 작은 힙

  최소 힙 : 아래가 크고, 위가 작은 힙


+ 시간 복잡도

  삽입, 삭제 O(log n)

  조회 O(n)

  특정 값 수정 O(n) + heapify 작업

  힙 정렬 O(n log n)


+ ## 우선순위 큐 (Queue Priority)

+ 큐가 하나 씩 순차적으로 쌓이는 것은 큐와 동일하지만 먼저 처리해야 할 일이 있다면, 순차적으로 쌓이는 큐의 규칙을 무시하고 우선순위를 제어해 앞쪽에 넣어 먼저 처리


+ 기존 큐는 O(1)로 빠르지만, 우선순위 큐는 이진 힙을 통해 구현하기 때문에 O(log n), 제한적인 조회 O(1)


+ ## 덱 (Deque)
  
+ 스택 + 큐의 형태

+ 자바스크립트 배열과 매우 유사

+ push, pop, shift, unshift

+ 시간 복잡도

  제한적인 조회 O(1), 삽입, 삭제 O(1)


+ ## 그래프 (Graph)

+ ## 해시 테이블 (Hash Table)

+ ## 레드 블랙 트리 (Red Black Tree)

+ ## 트리 순회 (Traversal)
