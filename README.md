# 자료구조


+ ## 시간복잡도

+ 표기법
  
  자료구조, 알고리즘의 성능을 표기하기 위함
  
  최선보다는 최악을 중점으로


+ n
  
  배열의 길이(데이터의 총 갯수)
  
  배열에서 특정 값을 찾는 작업량 -> n


+ Big-O
  
  최악의 경우

  
+ Theta
  
  Big-O === Big-Omega

  
+ Big-Omega
  
  최선의 경우


+ 시간 복잡도 빅오 표기법
  
  O(1) : 최선(상수)
  
  O(log n) : for문 i++처럼 순차적인 흐름이 아닌, 곱하기, 나누기, 배수 등 조건이 절반이 되는 상황
  
  O(n) : for문 (i++)
  
  O(n log n) : 이중 for문 중 바깥 for문인 i는 n (i++), 안쪽 for문이 j는 (예: j * 2)인 경우 / 여기까지는 선방

  O(n^2) : 이중 for문 (i++)
  
  O(n^3) : 삼중 for문 (i++) / 마지노선
  
  O(2n) : X
  
  O(n!) : X


+ ## 연결 리스트 (Linked List)

+ 활용처

  메모리 단편화 방지, 삽입/삭제 빈번할 때
  

+ 메모리에 [1, 2, 3, 4, 5] 형태의 배열과 객체가 존재한다면
  
  | A | B | C | D | E | F | G | H | I | J | K | L |
  | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
  | 배열 | 1 | 2 | 3 | 4 | 5 | 객체 | a | b | c | 6 |   |
  
  6을 추가하면 기존 배열의 마지막에 연속되게 추가될 것이라 생각했지만, 해당 위치에는 이미 객체가 선점하고 있다.

  그래서 메모리 K 위치에 6이 추가되었다.
  

  연속되지 않은 메모리 공간에 저장된 데이터를, 연속된 것처럼 연결해서 관리하기 위한 자료구조

  각 Node는 다음 Node의 주소를 저장하여 연결한 형태


+ 시간 복잡도
  생성 O(n), 조회 O(n), 수정 O(n), 삭제 O(n)

  공간 복잡도 - O(n)

  
+ ## 스택 (Stack)

+ 활용처

  함수 호출, 되돌리기(Undo)
  

+ LIFO : 후입선출
  
  length를 가질 수 있으며, 스택에 정해진 크기를 초과하면 스택오버플로우

  push↘  ↗pop
  
      │    │
      
      │    │
      
      └━━━━┘

    push O(1), pop O(1)


+ ## 큐 (Queue)

+ 활용처

  작업 대기열, BFS, 비동기 처리

  
+ FIFO : 선입선출

  대기열의 개념으로 한 번에 하나씩만 처리할 수 있는 프로그래밍 환경에서 사용

  ←shift [1, 2, 3, 4, 5] ←push

  push O(1), shift O(1)


+ ## 트리 (Tree)

+ 트리 구조
  
  트리의 시작점 : Root

  가지치기처럼 뻗어가는 가지 : Node

  가지의 마지막 : Leap

  HTML의 구조도 트리 구조로 볼 수 있음


+ 활용

  트리의 Node의 갯수에 대한 제한이 없기 때문에 알고리즘으로 트리를 활용하기 어려움

  그래서 트리의 모양에 제한을 둠 -> 이진 트리 (Binary Tree) - Node를 최대 2개로 제한


+ 이진 트리 종류

  + 정 이진 트리 (Full Binary Tree)

    자식 Node가 0 혹은 2 (자식 Node가 1개는 안됨)

  + 포화 이진 트리 (Perfect Binary Tree)

    leaf가 아닌 Node는 자식이 꼭 2개
    
    leaf는 모두 같은 Level에 있어야 하며, 같은 층에 leaf가 꽉 차있어야 함(삼각형 모양)

  + 완전 이진 트리 (Complete Binary Tree)

    Full과 Perfect의 중간

    왼쪽부터 하나 씩 데이터를 채우는 방식

    이 과정 중 나오는 모든 Tree들이 Complete Tree

    마지막 Level까지 꽉 차있지 않아도 되지만, Node가 왼쪽에서 오른쪽 방향으로 채워져 있어야 함.

  + 편향 이진 트리 (Degenerate(Skewed) Binary Tree)

    자식의 갯수가 모두 1개인 트리

    가장 비효율적인 이진 트리 (연결 리스트 수준의 트리 형태)

    모든 Node들이 diff가 0 혹은 1인 트리 (좌, 우 어느쪽으로 치우쳐져 있는지 판단할 때 diff를 사용)


  + 용어

    + Level (가지의 층)

      Root는 Level 1, 그 다음 2개로 나눠진 가지(자식)의 층 Level 2 ...

    + height
   
      Root로 부터 가지치기된 가지의 길이

    + diff

      Root의 diff는 1

      자신을 기준으로 왼쪽 최대 height와 오른쪽 최대 height의 차이


+ ## 이진 탐색 트리 (Binary Search Tree)

+ 활용처
  
  정렬된 데이터를 효율적으로 탐색, 삽입, 삭제해야 하는 상황


+ 이진 트리는 가지가 최대 2개이며 이진 탐색 트리에서 사용하기 좋은 트리는 Balanced Tree (Complete, Perfect는 Balabced일 수 밖에 없음)


+ Node를 기준으로 왼쪽은 작은 값, 오른쪽은 큰 값을 배치


+ 탐색 -> 정렬이 되었음을 의미

  정렬이 되어있어 특정 값에 접근할 때, 삽입, 조회, 삭제 모두 O(log n)

  단, Balanced Tree일 때 해당 (이진 탐색 트리는 Balanced를 보장하지 않음)

  Balanced를 보장하기 위해 AVL Tree, Red Black Tree 등 작업이 필요

  트리가 한 쪽으로만 채워져서 연결 리스트 형태가 된다면 삽입, 조회, 삭제 모두 O(n)


+ ## 이진 힙 (Binary Heap)

+ Complete Binary Tree를 사용

  Complete Binary Tree는 배열로 표현할 수 있음

  새로운 Node를 추가해도 힙 구조가 유지 되어야 함

  Node 삭제는 Root Node만 제거 가능하며 삭제 후 힙 구조가 유지 되어야 함

+ 배열에서 노드를 구하는 공식
  
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

  + 왼쪽 자식 노드를 구하는 공식 -> 인덱스 * 2 + 1

    2 * 2 + 1 = 5

    2 * 2 + 2 = 6

  + 오른쪽 자식 노드를 구하는 공식 -> 인덱스 * 2 + 2

    4 * 2 + 1 = 9
  
    4 * 2 + 2 = 10 (null)

  + 부모를 구하는 공식 -> Math.floor( (인덱스 - 1) / 2 )

    (7 - 1) / 2 = 3
    (8 - 1) / 2 = 3.5 = 3


+ 최대 힙 & 최소 힙

  최대 힙 : 위가 크고, 아래가 작은 힙

  최소 힙 : 아래가 크고, 위가 작은 힙


+ 시간 복잡도

  삽입, 삭제 O(log n)

  조회 O(n)

  특정 값 수정 O(n) + heapify 작업

  힙 정렬 O(n log n)


+ ## 우선순위 큐 (Queue Priority)

+ 큐가 하나 씩 순차적으로 쌓이는 것은 큐와 동일하지만 먼저 처리해야 할 일이 있다면, 순차적으로 쌓이는 큐의 규칙을 무시하고 우선순위를 제어해 앞쪽에 넣어 먼저 처리


+ 기존 큐는 O(1)로 빠르지만, 우선순위 큐는 이진 힙을 통해 구현하기 때문에 O(log n), 제한적인 조회 O(1)


+ ## 덱 (Deque)
  
+ 스택 + 큐의 형태

+ 자바스크립트 배열과 매우 유사

+ push, pop, shift, unshift

+ 시간 복잡도

  제한적인 조회 O(1), 삽입, 삭제 O(1)


+ ## 그래프 (Graph)

+ 트리의 일반적인 형태
  
  leaf가 없고, 서로 간의 연결 관계를 여러 개 가지고 있는 자료구조

+ 구조

  + 기존 트리 구조

    Root와 In-degree가 1개인 단방향 그래프

    Root, Node, leaf, Edge(선)

  + 그래프

    Vertex와 In-degree, Out-degree가 있는 방향과 무방향이 존재

    Vertex (트리의 Node 역할), Arc (트리의 Edge 역할)

+ degree

  In-degree : Vertex로 들어오는 Arc 갯수

  Out-degree : Vertex에서 다른 Vertex로 빠져나가는 Arc 갯수

+ 방향, 무방향

  무방향 : 화살표가 없으며, In, Out degree의 갯수가 같음

  방향 : 화살표가 양쪽에 있다면 양방형, 한쪽만 있다면 단방향

+ 표현

  + 그래프는 다양항 방법으로 표현이 가능

    + Vertex가 있고, 연결 관계인 Arc가 있다면 2차원 배열로 표현할 수 있음
      
    | \ | A | B | C | D |
    | --- | --- | --- | --- | --- |
    | A | 0 | 1 | 1 | 0 |
    | B | 1 | 0 | 0 | 1 |
    | C | 0 | 1 | 0 | 1 |
    | D | 0 | 0 | 0 | 0 |

    + 1차원 배열 2개로 표현
   
      Vertex = [A, B, C, D]

      VertexA = [B, C]  VertexB = [A, D]  VertexC = [B, D]  VertexD = []

  + 복잡도

    2차원 배열 방식은 쉽게 구현이 가능하며 시간 복잡도는 O(1), 공간 복잡도는 1차원 배열 방식보다 많이 차지

    1차원 배열 방식은 해당 Vertex가 누구와 연결되었는지 파악하기 어렵고 시간 복잡도는 O(n), 공간을 적게 차지

    2차원 배열 방식을 추천. 공간 복잡도 보다는 시간 복잡도를 낮추는게 효율적
      

+ ## 해시 테이블 (Hash Table)

+ 자바스크립트의 {} 객체와 유사

  객체는 key, value를 사용


+ 제약

  value를 저장할 때 용량 제한이 있음


+ 비둘기 집 원리

  n + 1개의 물건을 n개의 상자에 넣을 때, 적어도 한 상자에는 두 개 이상의 물건이 들어있음

  즉, 용량의 제한에 맞추기 위해 key, value들이 힌 칸에 여러 개가 들어갈 수 밖에 없음

  각 값을 어느 칸에 저장해야 할지 결정하는 것이 중요 - 신경쓰지 않으면 연결 리스트가 되어 O(n)으로 비효율

  칸에 제한이 있을 경우, 데이터를 칸에 최대한 겹치지 않게 고루 분배하는 것이 중요

+ 해시 함수

  key를 해시 함수를 통해 hash 값으로 변환

  해시 함수가 모두 같은 값을 반환한다면 연결 리스트가 되니 주의

  해시 함수의 방식에 따라 시간 복잡도가 O(1), O(log n), O(n)

  + 해시 충돌 (collision)

    만약 key가 모두 숫자라면 key를 capa(해시 테이블의 크기)로 나누어 나머지 값(hash)을 칸의 번호로 사용

+ 예시

  1 % 30 = 1 => {a: "A"}

  31 % 30 = 1 => {aa: "AA"}

  61 % 30 = 1 => {aaa: "AAA"}

  1 - a: "A", aa: "AA", aaa: "AAA"
  
  2 - b: 5, bb: 10
  
  3 - c: true
  
  ...
  
  30 - z: "ero"


  + 시간 복잡도

    생성, 조회, 삭제 모두 O(n / hash)


+ ## 트리 순회 (Traversal)

  + BFS, DFS - 자료구조에서 활용하는 대표적인 알고리즘
 
  <pre>
       ┌    1    ┐
     ┌ 2 ┐     ┌ 3 ┐
     4   5     6   7
  </pre>

  + 너비 우선 탐색 (BFS: Breadth First Search)
 
    [1, 2, 3, 4, 5, 6, 7]

    root부터 시작해서 root의 자식 노드, 그 자식 노드...

    같은 레벨인 root들을 먼저 적어주는 탐색 방법

    (1, (2, 3), (4, 5, 6, 7))


  + 깊이 우선 탐색 (DFS: Depth First Search)
 
    [1, 2, 4, 5, 3, 6, 7]

    자신의 자식을 먼저

    해당 root의 자식을 모두 탐색하고, 다른 자식을 탐색

    (1, (2, 4, 5), (3, 6, 7))

  + BFS는 Queue를 활용하고, DFS는 Stack를 활용하여 구현
 
    + BFS = Queue

      + [1]

        root를 넣는다.
        
        root를 Deque(shift)하고, 1을 표시

      + [2, 3]

        표시와 동시에 root의 자식 노드인 2, 3를 enqueue
       
        (자신이 deque되며 나가고, 자식들이 equeue되어 들어옴)

      + [3, 4, 5]
     
        2를 Deque하고, 2를 표시

        2의 자식 노드인 4, 5를 enqueue

      + [4, 5, 6, 7]

        3을 Deque하고, 3을 표시

        3의 자식 노드인 6, 7를 enqueue

      + [5, 6, 7]

        4를 Deque하고, 4를 표시

        4는 자식이 없으니 5, 6, 7을 반복해서 deque

        큐가 빌 때까지 반복
 
    + [1, 2, 3, 4, 5, 6, 7]

    + DFS = Stack
   
      + [1]
     
        root를 넣는다.

        root를 pop하고 1을 표시

      + [3, 2]
     
        표시와 동시에 root의 자식인 2, 3을 push

      + [7, 6, 2]

        3을 pop하고 3을 표시

        표시와 동시에 3의 자식인 6, 7을 push

      + [2]
     
        7을 pop하고 7을 표시

        7은 자식이 없으니 6을 pop하고 6을 표시

      + [5, 4]
     
        2룰 pop하고 2를 표시

        표시와 동시어 2의 자식인 4, 5를 push

      + []
           
        5를 pop하고 5를 표시

        5는 자식이 없으니 4를 pop하고 4를 표시

      + [1, 3, 7, 6, 2, 5, 4]
     
        처음 예상한 [1, 2, 4, 5, 3, 6, 7]와 다름

        이는 left와 right 어떤 것을 먼저 처리할 것이냐에 따라 순서를 결정하면 됨


  + 트리 순회 (Tree Traversal)
 
    + 3가지의 Order
 
      <pre>
          ┌    1    ┐
        ┌ 2 ┐     ┌ 3 ┐
        4   5     6   7
      </pre>
  
      [1, 2, 3, 4, 5, 6, 7]

      + Pre Order (대표적인 DFS)

        Tree를 기준으로 선이 왼쪽부터 차례대로 훓고 지나갈 때 출력

        [1, 2, 4, 5, 3, 6, 7]

      + In Order
     
          선이 Node의 아래쪽을 지나갈 때 출력

          [4, 2, 5, 1, 6, 3, 7]

      + Post Order

        선이 Node의 오른쪽을 지나갈 때 출력

        [4, 5, 2, 6, 7, 3, 1]


+ ## 레드 블랙 트리 (Red Black Tree)

  이진 탐색 트리를 기반 (왼쪽은 작은 값, 오른쪽은 큰 값) + Balanced Tree

  + 레드 블랙 트리 규칙

    1. 노드는 Red, Black 색상을 가짐
    2. Root의 색상은 반드시 Black
    3. 새로 추가된 노드의 색상은 Red
    4. Red는 연속(부모와 자식이 모두 Red)되면 안됨 - Black는 연속을 허용
    5. Red 노드의 자식은 Black
    6. Root에서 모든 leaf까지 Black의 갯수가 같아야 함
   
    <pre>
      ┌ B ┐
      B   B

      OK
    </pre>

    <pre>
      ┌ B
      B

      Fail (6번 조건 X)
    </pre>
    
    <pre>
      ┌ B
      R

      OK
    </pre>
    <pre>
      ┌ B
      R

      OK
    </pre>
    
    <pre>
        ┌ B ┐
      ┌ B   B
      B
      
      Fail (6번 조건 X)
    </pre>
    
    <pre>
        ┌ B ┐
      ┌ R   R
      R
      
      Fail (4번 조건 X)
    </pre>


  + 규칙 유지

    다양한 규칙에 맞춰 트리를 유지하기 위해 Recolor, Restructure 두 방식을 통해 구조를 유지

    Recolor - 삼촌잉 Red면 Recolor 수행
    Restructure - 삼촌이 Black이거나 없다면 Restructure 수행


  + Recolor

    <pre>
      ┌        B(할아버지) ┐
      R(부모) ┐            R(삼촌)
              R(나)
    </pre>

    부모와 삼촌을 Red에서 Black로, 할아버지를 Black에서 Red로 변경

    <pre>
      ┌        R(할아버지) ┐
      B(부모) ┐            B(삼촌)
              R(나)
    </pre>

    단, root는 어떤 상황에도 Black 유지

    <pre>
      ┌        B(할아버지) ┐
      B(부모) ┐            B(삼촌)
              R(나)
    </pre>

    recololr 수행 후 변경으로 인한 상위 노드 간의 규칙이 어긋나면 재귀를 통해 구조를 유지하는 작업을 수행함
